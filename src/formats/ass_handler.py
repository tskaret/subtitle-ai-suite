from pathlib import Path
from datetime import timedelta
from typing import List, Dict, Any, Optional

class AssHandler:
    """
    Handles the generation of Advanced SubStation Alpha (.ass) subtitle files.
    Supports basic styling and speaker colorization.
    """

    DEFAULT_ASS_STYLE = {
        "Name": "Default",
        "Fontname": "Arial",
        "Fontsize": "48",
        "PrimaryColour": "&H00FFFFFF",  # White
        "SecondaryColour": "&H000000FF",  # Blue (not used for Primary by us, but part of ASS spec)
        "OutlineColour": "&H00000000",  # Black
        "BackColour": "&H00000000",  # Black (shadow, but also used as fill color for boxes)
        "Bold": "0",
        "Italic": "0",
        "Underline": "0",
        "StrikeOut": "0",
        "ScaleX": "100",
        "ScaleY": "100",
        "Spacing": "0",
        "Angle": "0",
        "BorderStyle": "1",  # 1 = Outline+Shadow, 3 = Opaque Box
        "Outline": "2",
        "Shadow": "2",
        "Alignment": "2",  # 2 = bottom center
        "MarginL": "10",
        "MarginR": "10",
        "MarginV": "10",
        "Encoding": "1",  # 0 = ANSI, 1 = Default, 2 = Symbol, 3 = Mac, 4 = ShiftJIS, 5 = HANGUL, etc.
    }

    def __init__(self, default_style: Optional[Dict[str, str]] = None):
        self.default_style = default_style or self.DEFAULT_ASS_STYLE

    def _format_timestamp(self, seconds: float) -> str:
        """
        Formats a time in seconds to ASS timestamp format (H:MM:SS.cc).
        """
        # ASS timestamps are H:MM:SS.cc where cc are centiseconds
        total_seconds = int(seconds)
        centiseconds = int((seconds - total_seconds) * 100)
        hours = total_seconds // 3600
        minutes = (total_seconds % 3600) // 60
        seconds_part = total_seconds % 60
        return f"{hours}:{minutes:02}:{seconds_part:02}.{centiseconds:02}"

    def generate_ass(self, 
                     transcription_data: List[Dict[str, Any]], 
                     output_path: Path, 
                     speaker_colors: Optional[Dict[str, str]] = None):
        """
        Generates an ASS file from transcription data.

        Args:
            transcription_data (List[Dict[str, Any]]): A list of dictionaries,
                                                      where each dictionary represents a subtitle segment
                                                      and should contain 'start', 'end', 'text', and optionally 'speaker' keys.
            output_path (Path): The path where the ASS file will be saved.
            speaker_colors (Optional[Dict[str, str]]): A dictionary mapping speaker names to ASS color codes (e.g., '&H0000FF&' for blue).
        """
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        ass_header = f"""[Script Info]
; Script generated by Subtitle AI Suite
Title: {output_path.stem}
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: {self.default_style['Name']},{self.default_style['Fontname']},{self.default_style['Fontsize']},{self.default_style['PrimaryColour']},{self.default_style['SecondaryColour']},{self.default_style['OutlineColour']},{self.default_style['BackColour']},{self.default_style['Bold']},{self.default_style['Italic']},{self.default_style['Underline']},{self.default_style['StrikeOut']},{self.default_style['ScaleX']},{self.default_style['ScaleY']},{self.default_style['Spacing']},{self.default_style['Angle']},{self.default_style['BorderStyle']},{self.default_style['Outline']},{self.default_style['Shadow']},{self.default_style['Alignment']},{self.default_style['MarginL']},{self.default_style['MarginR']},{self.default_style['MarginV']},{self.default_style['Encoding']}
"""
        # Add speaker specific styles if colors are provided
        if speaker_colors:
            for speaker, color_code in speaker_colors.items():
                style_name = f"Speaker_{speaker}"
                ass_header += f"Style: {style_name},{self.default_style['Fontname']},{self.default_style['Fontsize']},{color_code},{self.default_style['SecondaryColour']},{self.default_style['OutlineColour']},{self.default_style['BackColour']},{self.default_style['Bold']},{self.default_style['Italic']},{self.default_style['Underline']},{self.default_style['StrikeOut']},{self.default_style['ScaleX']},{self.default_style['ScaleY']},{self.default_style['Spacing']},{self.default_style['Angle']},{self.default_style['BorderStyle']},{self.default_style['Outline']},{self.default_style['Shadow']},{self.default_style['Alignment']},{self.default_style['MarginL']},{self.default_style['MarginR']},{self.default_style['MarginV']},{self.default_style['Encoding']}\n"


        ass_events_header = "\n[Events]\nFormat: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n"
        
        with open(output_path, "w", encoding="utf-8") as f:
            f.write(ass_header)
            f.write(ass_events_header)

            for segment in transcription_data:
                start_time = segment.get("start", 0.0)
                end_time = segment.get("end", 0.0)
                text = segment.get("text", "")
                speaker = segment.get("speaker") # Assuming speaker is part of the segment data

                style_name = self.default_style['Name']
                if speaker_colors and speaker in speaker_colors:
                    style_name = f"Speaker_{speaker}"
                
                # Basic text formatting: remove newlines from text as ASS handles line breaks with \N
                formatted_text = text.replace('\n', '\\N')

                f.write(f"Dialogue: 0,{self._format_timestamp(start_time)},{self._format_timestamp(end_time)},{style_name},,{self.default_style['MarginL']},{self.default_style['MarginR']},{self.default_style['MarginV']},,{formatted_text.strip()}\n")
